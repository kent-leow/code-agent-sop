# Business Requirements to Development Workflow

A comprehensive 5-stage prompt system for transforming raw business requirements into complete application development with full traceability.

## Overview

This workflow transforms business inputs through systematic analysis into executable development tasks:

```
Raw Requirements → Analysis → Implementation Plan → User Stories → Tasks → Execution
```

## File Structure

```
.docs/
├── requirements/           # Input: Raw business requirements
│   ├── meeting-transcripts/
│   ├── stakeholder-interviews/
│   └── feature-requests/
├── analysis/              # Stage 1 Output: Structured requirements
│   ├── {domain}-requirements-v{version}.md
│   └── ...
├── overview-plan.json     # Stage 2 Output: Master implementation plan
├── user-stories/          # Stage 3 Output: Development stories
│   ├── phase-1/
│   │   ├── us-1.1.md
│   │   ├── us-1.2.md
│   │   └── ...
│   ├── phase-2/
│   └── ...
└── tasks/                 # Stage 4 Output: Implementation tasks
    ├── phase-1/
    │   ├── us-1.1/
    │   │   ├── implementation-tasks.md
    │   │   ├── api-spec.yaml
    │   │   └── database-schema.sql
    │   └── us-1.2/
    └── phase-2/
```

## Workflow Stages

### Stage 1: Requirements Analysis
**Prompt**: `1-requirements-analysis.prompt.md`
- **Input**: `.docs/requirements/**` (transcripts, documents, interviews)
- **Output**: `.docs/analysis/{domain}-requirements-v{version}.md`
- **Purpose**: Transform raw inputs into structured, comprehensive requirements

### Stage 2: Implementation Plan
**Prompt**: `2-implementation-plan.prompt.md`
- **Input**: `.docs/analysis/**` (all requirement files)
- **Output**: `.docs/overview-plan.json`
- **Purpose**: Create machine-readable master plan with architecture, phases, and technology

### Stage 3: User Stories
**Prompt**: `3-user-stories.prompt.md`
- **Input**: `.docs/overview-plan.json` + `.docs/requirements/**` (for context)
- **Output**: `.docs/user-stories/phase-{x}/us-{x}.{y}.md`
- **Purpose**: Convert plan modules into detailed user stories with acceptance criteria

### Stage 4: Implementation Tasks
**Prompt**: `4-implementation-tasks.prompt.md`
- **Input**: User story files from `.docs/user-stories/phase-{x}/us-{x}.{y}.md`
- **Output**: `.docs/tasks/phase-{x}/us-{x}.{y}/implementation-tasks.md`
- **Purpose**: Break stories into executable development tasks with technical specifications

### Stage 5: Task Execution
**Prompt**: `5-task-execution.prompt.md`
- **Input**: `.docs/tasks/phase-{x}/us-{x}.{y}/implementation-tasks.md`
- **Output**: Implemented code, tests, documentation
- **Purpose**: Execute tasks efficiently with validation and quality gates

## Naming Conventions

### Files & Folders
- **Requirements**: Descriptive names in snake_case
- **Analysis**: `{domain}-requirements-v{version}.md`
- **Plan**: `overview-plan.json`
- **Stories**: `us-{phase}.{story}.md` (e.g., `us-1.1.md`, `us-2.3.md`)
- **Tasks**: `phase-{phase}/us-{phase}.{story}/implementation-tasks.md`

### Identifiers
- **Requirements**: `REQ-{sequential-id}` (e.g., `REQ-001`, `REQ-002`)
- **Phases**: `phase-{number}` (e.g., `phase-1`, `phase-2`)
- **Stories**: `us-{phase}.{story}` (e.g., `us-1.1`, `us-2.3`)
- **Tasks**: Descriptive action-oriented names

## Quality Standards

### Traceability
- Every output traceable to original requirements
- Requirement IDs maintained throughout workflow
- Dependencies clearly documented

### Completeness
- No gaps between stages
- All business needs covered
- Technical architecture comprehensive

### Consistency
- Naming conventions followed throughout
- Standards maintained across all outputs
- Technology choices aligned

### Testability
- Acceptance criteria verifiable
- Implementation tasks executable
- Quality gates measurable

## Usage Instructions

1. **Prepare Input**: Place all business requirements in `.docs/requirements/`
2. **Stage 1**: Use requirements analysis prompt on all input files
3. **Stage 2**: Use implementation plan prompt on all analysis files
4. **Stage 3**: Use user stories prompt with overview-plan.json
5. **Stage 4**: Use implementation tasks prompt on each user story
6. **Stage 5**: Use task execution prompt to implement each task

## Benefits

- **Complete Traceability**: Every line of code traces back to business need
- **Comprehensive Planning**: No missed requirements or technical debt
- **Iterative Development**: Phased approach enables agile delivery
- **Quality Assurance**: Built-in validation at every stage
- **Team Alignment**: Single source of truth for all stakeholders
- **Risk Mitigation**: Dependencies and risks identified early

## Success Metrics

- **Requirements Coverage**: 100% of business needs addressed
- **Technical Consistency**: Coherent architecture and technology choices
- **Development Efficiency**: Clear, executable tasks for developers
- **Quality Assurance**: Comprehensive testing and validation
- **Timeline Accuracy**: Realistic estimates and milestone tracking
